Цели
====

Получить практические навыки разработки сервисов (started и bound) и
Broadcast Receivers.

Задачи
======

Задача 1. Started сервис для скачивания изображения
---------------------------------------------------

### Задание

На основе кода из предыдущей лабораторной работы разработать started
service, скачивающий файл из интернета. URL изображения для скачивания
должен передаваться в Intent. Также необходимо убедиться (и описать
доказательство), что код для скачивания исполняется не в UI потоке

Добавить в разработанный сервис функцию отправки broadcast-сообщения по
завершении скачивания. Сообщение (Intent) должно содержать путь к
скачанному файлу.

### Решение

При обработке нажатия на кнопку загрузки изображения в Activity1
производится запуск IntentService, в качестве аргументов Intent-у
передается URL картинки для скачивания:

![](media/image1.png){width="5.427841207349081in"
height="1.6668996062992125in"}

Рисунок 1 onClickListener кнопки загрузки

Далее в отдельном потоке начинает исполнение кода из onHandleIntent
IntentService. При успешной загрузке формируется broadcast-сообщение о
загрузке. При этом в Intent добавляется путь к загруженному изображению
на SD-карте.

![](media/image2.png){width="6.496527777777778in" height="5.30625in"}

Рисунок 2 IntentService.kt

На следующем этапе вступает в дело BroadcastReciever, который принимает
broadcast-сообщение и формирует intent для перезапуска текущей Activity:

![](media/image3.png){width="5.031952099737532in"
height="2.166969597550306in"}

Рисунок 3 BroadcastReciever

Затем при пересоздании Activity происходит переход по условию (path !=
null), после чего по полученному пути производится загрузка изображения
на экран. По уничтожении Activity происходит отписка от рассылки.

![](media/image4.png){width="6.496527777777778in"
height="6.151388888888889in"}

Рисунок 4 Activity1.kt

В Logcat выводятся сообщения о потоках, в которых выполняются задачи.
Здесь можно убедиться, что IntentService выделяет отдельный поток для
выполнения кода. Сервис активируется, когда необходимо, поочередно
обрабатывает все Intent-ы (если их много), после чего закрывается, если
новых Intent-ов не поступало.

![](media/image5.png){width="6.496527777777778in"
height="0.6805555555555556in"}

Рисунок 5 вывод Logcat

Задача 2. Broadcast Receiver
----------------------------

### Задание

Разработать два приложения:

-   Первое приложение содержит 1 activity с 1 кнопкой, при нажатии на
    которую запускается сервис по скачиванию файла;

-   Второе приложение содержит 1 broadcast receiver и 1 activity.
    Broadcast receiver по получении сообщения из сервиса инициирует
    отображение *пути* к изображению в TextView в Activity.

### Решение

Фактически решение данной задачи описано в предыдущем пункте. Отметим
основные изменения:

-   Теперь broadcast-сообщение ловится из другого приложения, а не
    просто отдельной Activity;

-   Вместо самой картинки на вывод отправляется путь к ней в
    файловой системе.

В качестве приложения с сервисом для скачивания и отправителя
широковещательных сообщений используем разработанную ранее Activity1.
Теперь напишем второе приложение, которое станет принимать
broadcast-сообщения:

![](media/image6.png){width="6.496527777777778in"
height="7.930555555555555in"}

Рисунок 6 MainActivity.kt

Логика работы аналогична таковой для приложения, разработанного в
предыдущем пункте.

Задача 3. Bound Service для скачивания изображения
--------------------------------------------------

### Задание

Сделать разработанный сервис одновременно bound и started:
переопределить метод onBind. Из тела метода возвращать IBinder,
полученный из
класса [Messenger](https://developer.android.com/guide/components/bound-services?hl=ru#Messenger).
Убедиться (доказательство привести в отчете), что код скачивания файла
исполняется не в UI потоке.

Изменить способ запуска сервиса в первом приложении:
вместо startService использовать bindService. При нажатии на кнопку
отправлять
сообщение [Message](https://developer.android.com/reference/android/os/Message.html?hl=ru),
используя класс Messenger, полученный из интерфейса IBinder в
методе [onServiceConnected](https://developer.android.com/reference/android/content/ServiceConnection.html?hl=ru#onServiceConnected(android.content.ComponentName,%20android.os.IBinder)).

Добавить в первое приложение TextView, а в сервис –
отправку [обратного](https://developer.android.com/reference/android/os/Message.html?hl=ru#replyTo) сообщения
с местоположением скачанного файла. При получении сообщения от сервиса
приложение должно отобразить путь к файлу на экране.

Разработанный сервис должен быть одновременно bound и started. Если
получен intent через механизм started service, то сервис скачивает файл
и отправляет broadcast (started service не знает своих клиентов и не
предназначен для двухсторонней коммуникации). Если получен message через
механизм bound service, то скачивается файл и результат отправляется
тому клиенту, который запросил этот файл (т.к. bound service знает всех
своих клиентов и может им отвечать).

### Решение

Перепишем обработчик нажатия кнопки в Activity3:

![](media/image7.png){width="6.209199475065617in"
height="9.00125656167979in"}

Рисунок 7 Activity3.kt

При необходимости по нажатию на кнопку происходит привязка к сервису.

Если же клиент уже подключен к сервису, через sendRequest() посылается
запрос на скачивание картинки. В Message передается адрес возврата, флаг
запроса и URL изображения, упакованный в Bundle.

Объект ServiceConnection имеет следующий вид:

![](media/image8.png){width="5.917492344706911in"
height="2.7608016185476814in"}

Рисунок 8 ServiceConnection

Также написан обработчик ответа сервера:

![](media/image9.png){width="4.823590332458442in"
height="2.792055993000875in"}

Рисунок 9 OncomingHandler

В обработчике переопределен метод handleMessage: теперь по интересующему
нас флагу устанавливается новое значение переменной, содержащей путь к
загруженной картинке.

К разработанному в приложении 1 сервису добавились переопределенные
функции onBind и HandleMessage:

![](media/image10.png){width="6.496527777777778in"
height="7.576388888888889in"}

Рисунок 10 onBind и HandleMessage

Метод onBind вызывается для первого подключившегося клиента. Далее
запросы от разработанного клиента к серверу организуются в очередь к
IncomingHandler(). Обработчик сообщений проверяет флаг, после чего в
отдельной корутине загружает картинку, кладет адрес полученного файла в
Bundle и отправляет клиенту, воспользовавшись обратным адресом в поле
replyTo. Затем Message обрабатывается на стороне клиента.

В ходе выполнения работы также была проверено, что задача скачивания
изображения вынесена в отдельный поток:

![](media/image11.png){width="6.496527777777778in"
height="0.7055555555555556in"}

Рисунок 11 Вывод в Logcat

Выводы
======

В ходе выполнения лабораторной работы на примере IntentService
исследованы сервисы и методы взаимодействия с ними. Рассмотрены основные
виды сервисов (started-сервисы и bound-сервисы), отработаны механизмы
пересылки данных между элементами Context. Также изучен принцип
организации работы класса Messenger, облегчающий реализацию
взаимодействия с bound-сервисами.

Получены практические навыки разработки Broadcast Receivers — изучен
механизм отправки broadcast-сообщений с помощью метода sendBroadcast,
представляемое классом BroadcastReceiver API для реализации компонентов
приложения, которые способны принимать и обрабатывать
broadcast-сообщения, и необходимые для регистрации Broadcast Receivers в
системе действия.
