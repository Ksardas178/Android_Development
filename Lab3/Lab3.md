1.
# Цели

- Ознакомиться с методом обработки жизненного цикла activity/fragment при помощи Lifecycle-Aware компонентов;
- Изучить основные возможности навигации внутри приложения: создание новых activity, navigation graph.

1.
# Задачи

  1.
## Задача 1. Activity

    1.
### Задание

Ознакомление с Lifecycle-AwareComponents по документации и выполнение codelabs.

    1.
### Решение

- На первом шаге для сохранения состояния при поворотах экрана использована ViewModel, иначе таймер сбрасывался бы каждый раз при разрушении. ViewModel же не уничтожается вместе с owner-ом при изменении конфигурации устройства (поворот экрана). Новый экземпляр владельца повторно подключается к существующей ViewModel. Запуская код, убеждаемся: при повороте экрана или переходе в другое в приложение с возвратом обратно таймер не сбрасывается.
- На следующем этапе таймер, использованный на предыдущем шаге, заменяется на собственный, который использует timer и обновляет UI раз в секунду;
 Теперь при запуске приложения Logcat-журнал также обновляется каждую секунду, если пользователь не переключается на другое приложение, при этом таймер всё так же работает и подсчитывает секунды;
- На очередном шаге мы обновляем класс под названием BoundLocationManager, чтобы он учитывал жизненный цикл: он будет связываться, наблюдать и реагировать на изменения в LifecycleOwner. Чтобы класс мог наблюдать за жизненным циклом Activity, мы должны добавить его в качестве наблюдателя. Для этого даём объекту BoundLocationManager команду наблюдать за жизненным циклом;
 Теперь при запуске приложения в логе отображается добавление и удаление наблюдателя.
- На данном этапе разрешается обмен данными между фрагментами с использованием ViewModel. Нашей задачей является соединение фрагментов с ViewModel, чтобы изменение одного SeekBar влекло за собой обновление второго SeekBar;
- На заключительном шаге наша задача – сохранение состояния приложения, чтобы информация не была потеряна в случае остановки процесса. При запуске исходного кода приложения мы можем сохранить информацию в ViewModel, и при принудительном завершении процесса заметно, что значение в нем не сохранилось, однако EditText восстановил своё состояние. Это связано с тем, что некоторые элементы пользовательского интерфейса, включая EditText, сохраняют данные, используя собственную реализацию onSaveInstanceState. Это состояние восстанавливается после завершения процесса так же, как оно восстанавливается после изменения конфигурации.
 Для сохранения информации в ViewModel нам нужно в файл SavedStateViewModel.java добавить новый конструктор;
- По итогу выполнения работы видно, что после повторного запуска приложения его состояние сохранено во ViewModel.

    1.
### промежуточные итоги

Произведено знакомство со следующими компонентами ActivityLifecycle:

- LiveData – компонент, позволяющий наблюдать за изменениями данных в нескольких компонентах приложения, не создавая явных жёстких зависимостей между ними. Он учитывает сложные жизненные циклы компонентов приложения, включая действия, фрагменты, службы или любой LifecycleOwner, определённый в приложении. LiveData управляет подписками наблюдателей, приостанавливая подписки на остановленные объекты LifecycleOwner и отменяя подписки на завершённые объекты LifecycleOwner;
- LifecycleOwner — интерфейс, реализованный классами AppCompatActivity и Fragment. Мы можем подписать другие компоненты на объекты-владельцы, реализующие данный интерфейс, для наблюдения за изменениями в жизненном цикле владельца;
- ViewModel предоставляет способ создавать и извлекать объекты, привязанные к определенному жизненному циклу.

  1.
## Задача 2. Навигация (startActivityForResult)

    1.
### Задание

Реализация навигации между экранами одного приложения согласно приведенному изображению с помощью Activity, Intent и StartActivityForResult.

![](RackMultipart20210401-4-wla4g9_html_ec8633af2fa4b8ae.png)

**Рисунок 1 Окна создаваемых Activity**

Согласно представленному вместе с заданием на работу описанию возможен следующий ход решения:

- Activity1 всегда запускает Activity2. Можно использовать Activity1#startActivity для этой операции;
- Activity2 может вернуться в Activity1 или перейти в новую Activity3. Для первой операции можно просто использовать метод Activity2#finish. Вторая операция интереснее, т.к. нам понадобится узнать, что привело к завершению Activity3. Используем startActivityForResult;
- Activity3 может вернуться в Activity1 или в Activity2. Для возврата в Activity2 можно просто использовать метод Activity3#finish. Для возврата в Activity1 понадобится помощь со стороны Activity2. Для того, чтобы известить Activity2 о необходимости завершиться, используем код возврата, который передадим с помощью метода Activity3#setResult, только после этого вызовем метод Activity3#finish. Activity2 в методе Activity2#onActivityResult должна проверить причину завершения Activity3: если Activity3 завершилась из-за того, что пользователь нажал toFirst, то вызовем метод Activity2#finish. В случае toSecond дополнительных действий не требуется.

Переопределение ключевой функции onActivityResult совместно с вызовом данной Activity представлено на изображении ниже:

![](RackMultipart20210401-4-wla4g9_html_a31799f3eb4bc376.png)

**Рисунок 2 Вызов Activityforresult и переопределение алгоритма обработки результата**

  1.
## Задача 3. Навигация (флаги Intent/атрибуты Activity)

    1.
### Задание

Представить решение предыдущей задачи с помощью Activity, Intent либоатрибутов Activity.

    1.
### Решение

Решение данной задачи по большей части сводится к использованию флага FLAG\_ACTIVITY\_CLEAR\_TOP, позволяющего найти в backstack (при наличии) ранее созданную Activity, открыть ее и закрыть все Activity, которые располагаются выше нее в стеке. Таким образом, при возврате в Activity с меньшим порядковым номером, чем текущая, данный флаг позволяет очищать backstack и сохранять требуемый порядок вызовов. Вызовы оставшихся Activity можно произвести без установки флагов.

  1.
## Задача 4. Навигация (флаги Intent/атрибуты Activity)

    1.
### Задание

Дополнить граф переходов предыдущего задания каким-либо переходом с целью демонстрации атрибута Activity либо флага Intent, не использованного ранее для решения задачи.

    1.
### Решение

Граф переходов дополнен одной Activity с целью демонстрации работы флага ACTIVITY\_SINGLE\_TOP. Данный флаг не разрешает создавать Activity, если на вершине стека уже лежит экземпляр Activity с совпадающим типом, что наглядно демонстрируется при просмотре backstack-а после нескольких нажатий на кнопку запуска новой Activity.

![](RackMultipart20210401-4-wla4g9_html_2b1a35c7a7d146c3.png) ![](RackMultipart20210401-4-wla4g9_html_8d0a1e67b7f3a53b.png)

**Рисунок 3 Разработанная Activity**

**Рисунок 4 Дополненная Activity 3**

  1.
## Задача 5. Навигация (Fragments, Navigation Graph)

    1.
### Задание

Представить решение предыдущей задачи с использованием NavigationGraph. Activity (кроме Activity &#39;About&#39;) должны быть заменены на фрагменты. Сравнить решения.

    1.
### Решение

В рамках задания был разработан следующий граф переходов между фрагментами:

![](RackMultipart20210401-4-wla4g9_html_ce81226bc61d0f57.png)

**Рисунок 5 Граф переходов**

Примечание: в силу особенностей использованного в прошлом задании флага необходимость в вызове добавленного фрагмента из него же намеренно не реализуется (флаг ACTIVITY\_SINGLE\_TOP).

Решение с помощью фрагментов выглядит изящнее на уровне UI и анимаций переключения состояний, при этом позволяя использовать наглядное представление переходов на стадии разработки, что является несомненным преимуществом данного способа.

1.
# Выводы

В ходе выполнения лабораторной работы исследованы возможности навигации внутри приложения: startActivityForResult, startActivity и NavigationGraph (связка NavHost, NavController и Navigation-ресурса), выполняющий отображение фрагментов по разработанному графу навигации.
 Также затронуты жизненные циклы Activity/Fragment и изучены основные флаги Intent-ов для переключения Activity.
