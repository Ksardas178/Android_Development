1 ЦЕЛИ
• Ознакомиться с методом обработки жизненного цикла activity/fragment при помощи Lifecycle-Aware компонентов;
• Изучить основные возможности навигации внутри приложения: создание новых activity, navigation graph.
2 ЗАДАЧИ
2.1 ЗАДАЧА 1. ACTIVITY
2.1.1 ЗАДАНИЕ
Ознакомление с Lifecycle-Aware Components по документации и выполнение codelabs.
2.1.2 РЕШЕНИЕ
• На первом шаге для сохранения состояния при поворотах экрана использована ViewModel, иначе таймер сбрасывался бы каждый раз при разрушении. ViewModel же не уничтожается вместе с owner-ом при изменении конфигурации устройства (поворот экрана). Новый экземпляр владельца повторно подключается к существующей ViewModel. Запуская код, убеждаемся: при повороте экрана или переходе в другое в приложение с возвратом обратно таймер не сбрасывается.
• На следующем этапе таймер, использованный на предыдущем шаге, заменяется на собственный, который использует timer и обновляет UI раз в секунду;
Теперь при запуске приложения Logcat-журнал также обновляется каждую секунду, если пользователь не переключается на другое приложение, при этом таймер всё так же работает и подсчитывает секунды;
• На очередном шаге мы обновляем класс под названием BoundLocationManager, чтобы он учитывал жизненный цикл: он будет связываться, наблюдать и реагировать на изменения в LifecycleOwner. Чтобы класс мог наблюдать за жизненным циклом Activity, мы должны добавить его в качестве наблюдателя. Для этого даём объекту BoundLocationManager команду наблюдать за жизненным циклом;
Теперь при запуске приложения в логе отображается добавление и удаление наблюдателя.
• На данном этапе разрешается обмен данными между фрагментами с использованием ViewModel. Нашей задачей является соединение фрагментов с ViewModel, чтобы изменение одного SeekBar влекло за собой обновление второго SeekBar;
• На заключительном шаге наша задача – сохранение состояния приложения, чтобы информация не была потеряна в случае остановки процесса. При запуске исходного кода приложения мы можем сохранить информацию в ViewModel, и при принудительном завершении процесса заметно, что значение в нем не сохранилось, однако EditText восстановил своё состояние. Это связано с тем, что некоторые элементы пользовательского интерфейса, включая EditText, сохраняют данные, используя собственную реализацию onSaveInstanceState. Это состояние восстанавливается после завершения процесса так же, как оно восстанавливается после изменения конфигурации.
Для сохранения информации в ViewModel нам нужно в файл SavedStateViewModel.java добавить новый конструктор;
• По итогу выполнения работы видно, что после повторного запуска приложения его состояние сохранено во ViewModel.
2.1.3 ПРОМЕЖУТОЧНЫЕ ИТОГИ
Произведено знакомство со следующими компонентами Activity Lifecycle:
• LiveData – компонент, позволяющий наблюдать за изменениями данных в нескольких компонентах приложения, не создавая явных жёстких зависимостей между ними. Он учитывает сложные жизненные циклы компонентов приложения, включая действия, фрагменты, службы или любой LifecycleOwner, определённый в приложении. LiveData управляет подписками наблюдателей, приостанавливая подписки на остановленные объекты LifecycleOwner и отменяя подписки на завершённые объекты LifecycleOwner;
• LifecycleOwner — интерфейс, реализованный классами AppCompatActivity и Fragment. Мы можем подписать другие компоненты на объекты-владельцы, реализующие данный интерфейс, для наблюдения за изменениями в жизненном цикле владельца;
• ViewModel предоставляет способ создавать и извлекать объекты, привязанные к определенному жизненному циклу.
2.2 ЗАДАЧА 2. НАВИГАЦИЯ (STARTACTIVITYFORRESULT)
2.2.1 ЗАДАНИЕ
Реализация навигации между экранами одного приложения согласно приведенному изображению с помощью Activity, Intent и StartActivityForResult.

Рисунок 1 Окна создаваемых Activity
Согласно представленному вместе с заданием на работу описанию возможен следующий ход решения:
• Activity1 всегда запускает Activity2. Можно использовать Activity1#startActivity для этой операции;
• Activity2 может вернуться в Activity1 или перейти в новую Activity3. Для первой операции можно просто использовать метод Activity2#finish. Вторая операция интереснее, т.к. нам понадобится узнать, что привело к завершению Activity3. Используем startActivityForResult;
• Activity3 может вернуться в Activity1 или в Activity2. Для возврата в Activity2 можно просто использовать метод Activity3#finish. Для возврата в Activity1 понадобится помощь со стороны Activity2. Для того, чтобы известить Activity2 о необходимости завершиться, используем код возврата, который передадим с помощью метода Activity3#setResult, только после этого вызовем метод Activity3#finish. Activity2 в методе Activity2#onActivityResult должна проверить причину завершения Activity3: если Activity3 завершилась из-за того, что пользователь нажал toFirst, то вызовем метод Activity2#finish. В случае toSecond дополнительных действий не требуется.

Переопределение ключевой функции onActivityResult совместно с вызовом данной Activity представлено на изображении ниже:


Рисунок 2 Вызов Activity for result и переопределение алгоритма обработки результата
2.3 ЗАДАЧА 3. НАВИГАЦИЯ (ФЛАГИ INTENT/АТРИБУТЫ ACTIVITY)
2.3.1 ЗАДАНИЕ
Представить решение предыдущей задачи с помощью Activity, Intent либо атрибутов Activity.
2.3.2 РЕШЕНИЕ
Решение данной задачи по большей части сводится к использованию флага FLAG_ACTIVITY_CLEAR_TOP, позволяющего найти в backstack (при наличии) ранее созданную Activity, открыть ее и закрыть все Activity, которые располагаются выше нее в стеке. Таким образом, при возврате в Activity с меньшим порядковым номером, чем текущая, данный флаг позволяет очищать backstack и сохранять требуемый порядок вызовов. Вызовы оставшихся Activity можно произвести без установки флагов.

2.4 ЗАДАЧА 4. НАВИГАЦИЯ (ФЛАГИ INTENT/АТРИБУТЫ ACTIVITY)
2.4.1 ЗАДАНИЕ
Дополнить граф переходов предыдущего задания каким-либо переходом с целью демонстрации атрибута Activity либо флага Intent, не использованного ранее для решения задачи.
2.4.2 РЕШЕНИЕ
Граф переходов дополнен одной Activity с целью демонстрации работы флага ACTIVITY_SINGLE_TOP. Данный флаг не разрешает создавать Activity, если на вершине стека уже лежит экземпляр Activity с совпадающим типом, что наглядно демонстрируется при просмотре backstack-а после нескольких нажатий на кнопку запуска новой Activity.

Рисунок 3 Разработанная Activity
Рисунок 4 Дополненная Activity 3

2.5 ЗАДАЧА 5. НАВИГАЦИЯ (FRAGMENTS, NAVIGATION GRAPH)
2.5.1 ЗАДАНИЕ
Представить решение предыдущей задачи с использованием Navigation Graph. Activity (кроме Activity ‘About’) должны быть заменены на фрагменты. Сравнить решения.
2.5.2 РЕШЕНИЕ
В рамках задания был разработан следующий граф переходов между фрагментами:

Рисунок 5 Граф переходов
Примечание: в силу особенностей использованного в прошлом задании флага необходимость в вызове добавленного фрагмента из него же намеренно не реализуется (флаг ACTIVITY_SINGLE_TOP).
Решение с помощью фрагментов выглядит изящнее на уровне UI и анимаций переключения состояний, при этом позволяя использовать наглядное представление переходов на стадии разработки, что является несомненным преимуществом данного способа.

3 ВЫВОДЫ
В ходе выполнения лабораторной работы исследованы возможности навигации внутри приложения: startActivityForResult, startActivity и Navigation Graph (связка NavHost, NavController и Navigation-ресурса), выполняющий отображение фрагментов по разработанному графу навигации. 
Также затронуты жизненные циклы Activity/Fragment и изучены основные флаги Intent-ов для переключения Activity.
16


