Цели
====

-   Получить практические навыки разработки многопоточных приложений:

    -   Организация обработки длительных операций в background (worker)
        thread:

        -   Запуск фоновой операции (coroutine/asynctask/thread);

        -   Остановка фоновой операции (coroutine/asynctask/thread);

    -   Публикация данных из background (worker) thread в main (ui)
        thread;

-   Освоить 3 основные группы API для разработки многопоточных
    приложений:

    -   Kotlin Coroutines;

    -   AsyncTask;

    -   Java Threads.

Задачи
======

Задача 1. Альтернативные решения задачи "не секундомер" из Лаб. 2
-----------------------------------------------------------------

### Задание

Использовать приложение "не секундомер", получившееся в результате
выполнения [лабораторной работы
№2](https://github.com/andrei-kuznetsov/android-lectures/blob/master/labs/02/TASK.md).
Разработать несколько альтернативных приложений "не секундомер",
отличающихся друг от друга организацией многопоточной работы. Описать
все известные решения.

### Решение 1 (Java Threads)

В ходе решения разработан следующий код MainActivity:

![image](https://user-images.githubusercontent.com/43096732/114415533-74c09d00-9bb8-11eb-9e9e-5f83c2fc615e.png)

Рисунок 1 MainActivity.kt

Переопределены методы onPause и onResume:

![image](https://user-images.githubusercontent.com/43096732/114415548-78542400-9bb8-11eb-8c56-c73af8e2052a.png)

Рисунок 2 Переопределение методов onPause и onResume

Для запуска нового потока создается экземпляр класса Thread с передачей
ему экземпляра Runnable, в котором описан код для выполнения. На
полученном потоке вызывается метод start. По исполнении кода (либо, как
в нашем случае, завершения цикла по ошибке, порождаемой вызовом sleep на
прерванном потоке) созданный поток завершает выполнение. Управление
выполнением кода извне осуществляется с помощью связки функций interrupt
и interrupted. Interrupt позволяет установить внутренний флаг, который
затем проверяется в переданном на выполнение коде с помощью
вспомогательной функции (обычно бросающей исключение при соответствующем
значении флага).

Так как из рабочих потоков нельзя напрямую взаимодействовать с UI,
обновление интерфейса происходит посредством метода View.post,
передающего в очередь сообщений главного (UI) потока задачу обновить
привязанное поле (см. функцию updateTimer).

### Решение 2 (AsyncTask)

Разработанный класс MainActivity:

![image](https://user-images.githubusercontent.com/43096732/114415610-82762280-9bb8-11eb-8aac-f45a97525904.png)

Рисунок 3 MainActivity.kt

В данной реализации для организации многопоточности использован класс
AsyncTask (deprecated), предоставляющий более удобный интерфейс
взаимодействия с потоками. При наследовании абстрактного класса
переопределен метод doInBackground.

При создании экземпляра класса и вызова метода execute() экземпляр во
вспомогательном потоке проходит через собственный жизненный цикл. Влиять
на выполнение AsyncTask из других потоков позволяет связка функции
cancel и свойства isCancelled.

![image](https://user-images.githubusercontent.com/43096732/114415621-86a24000-9bb8-11eb-8a34-1d8e523086ed.png)

Рисунок 4 Вложенный класс MyTask

### Решение 3 (Kotlin Coroutines)

Корутины являются "обёрткой" над потоками и более просты в
использовании. В onResume запускается корутина, отвечающая за счёт. Она
представляет из себя бесконечный цикл, остановить который можно только
вместе с отменой самой корутины. Это производится с помощью job.cancel в
onPause.

![image](https://user-images.githubusercontent.com/43096732/114415655-902ba800-9bb8-11eb-8988-8453a124e1c7.png)

Рисунок 5 Класс MainActivity.kt

Задача 2. Загрузка картинки в фоновом потоке (AsyncTask)
--------------------------------------------------------

### Задание

Создать приложение, которое скачивает картинку из интернета и размещает
ее в ImaveView в Activity на основе предоставленного кода.

### Решение

Разработанный код MainActivity:

![image](https://user-images.githubusercontent.com/43096732/114415696-9752b600-9bb8-11eb-9b82-73da03ec316d.png)

Рисунок 6 MainActivity.kt

По нажатию на кнопку создается экземпляр класса DownloadImage, далее на
нем вызывается execute, после чего задача решается во вспомогательном
потоке.

При наследовании абстрактного класса для DownloadImage переопределен ряд
методов, а именно:

-   onPreExecute;

-   doInbackground;

-   onPostExecute.

Помимо переопределения методов AsyncTask добавлена функция загрузки
изображения по заданному
URL-адресу:

![image](https://user-images.githubusercontent.com/43096732/114415742-a20d4b00-9bb8-11eb-8700-e64bfc80637e.png)

Рисунок 7 Класс DownloadImage

Задача 3. Загрузка картинки в фоновом потоке (Kotlin Coroutines)
----------------------------------------------------------------

### Задание

Переписать предыдущее приложение с помощью Kotlin Coroutines.

### Решение

Для решения задачи разработан следующий код MainActivity:

![image](https://user-images.githubusercontent.com/43096732/114415757-a76a9580-9bb8-11eb-801a-687472e9ea95.png)

Рисунок 8 MainActivity.kt

В приведенной реализации использованы вложенные корутины. Dispatchers.IO
указывает корутине взять один из I/O потоков и выполняться в нём.
Предполагается, что в нем станут производиться длительные операции, а
также действия, связанные с I/O и работой с сетью.

Задача 4. Использование сторонних библиотек
-------------------------------------------

### Задание

Применить одну из предложенных стандартных библиотек для решения задачи
скачивания изображения в фоне.

Выбранная библиотека: Picasso.

### Решение

Добавим необходимые зависимости в Gradle(app)-файл:

***dependencies {***

> ***implementation 'com.squareup.picasso:picasso:2.71828'\
> …***

***}***

Воспользуемся предложенным на StackOverflow кодом для загрузки
изображения:

***Picasso.get().load("http://img\_url").into(imageView)***

Добавим код в обработчик нажатия на кнопку:

![image](https://user-images.githubusercontent.com/43096732/114415799-b18c9400-9bb8-11eb-85f0-19e2caee5eeb.png)

Рисунок 9 Загрузка картинки с помощью библиотеки Picasso

Выводы
======

В ходе выполнения лабораторной работы приобретены навыки разработки
многопоточных приложений, усвоены различия между UI-потоками, потоками
ввода-вывода и рабочими потоками, рассмотрены способы взаимодействия с
UI из рабочих потоков. Также освоены три основных API для разработки
многопоточных приложений:

-   Java Threads – программное представление потока процесса, который
    запускается с помощью создания экземпляра класса Thread и вызова
    функции start, выполнение которого может управляться извне при
    помощи вызова функции interrupt и контроля флага interrupted в
    исполняемом коде;

-   AsyncTask – обладающее жизненным циклом представление задачи,
    выполняемой в рабочем потоке, callback-методы которой выполняются
    как в рабочих потоках для выполнения самой задачи, так и в UI-потоке
    для отображения результатов и изменений;

-   Kotlin Coroutines – программное представление прерываемой
    сопрограммы, которая может быть либо приостановлена для переключения
    на выполнение другого кода, либо запущена параллельно вызываемой
    подпрограмме в отдельных потоках.
