Цели
====

-   Получить практические навыки разработки многопоточных приложений:

    -   Организация обработки длительных операций в background (worker)
        thread:

        -   Запуск фоновой операции (coroutine/asynctask/thread);

        -   Остановка фоновой операции (coroutine/asynctask/thread);

    -   Публикация данных из background (worker) thread в main (ui)
        thread;

-   Освоить 3 основные группы API для разработки многопоточных
    приложений:

    -   Kotlin Coroutines;

    -   AsyncTask;

    -   Java Threads.

Задачи
======

Задача 1. Альтернативные решения задачи "не секундомер" из Лаб. 2
-----------------------------------------------------------------

### Задание

Использовать приложение "не секундомер", получившееся в результате
выполнения [лабораторной работы
№2](https://github.com/andrei-kuznetsov/android-lectures/blob/master/labs/02/TASK.md).
Разработать несколько альтернативных приложений "не секундомер",
отличающихся друг от друга организацией многопоточной работы. Описать
все известные решения.

### Решение 1 (Java Threads)

В ходе решения разработан следующий код MainActivity:

![](media/image1.png){width="5.2715693350831145in"
height="5.615367454068242in"}

Рисунок 1 MainActivity.kt

Переопределены методы onPause и onResume:

![](media/image2.png){width="4.479792213473316in"
height="5.229896106736658in"}

Рисунок 2 Переопределение методов onPause и onResume

Для запуска нового потока создается экземпляр класса Thread с передачей
ему экземпляра Runnable, в котором описан код для выполнения. На
полученном потоке вызывается метод start. По исполнении кода (либо, как
в нашем случае, завершения цикла по ошибке, порождаемой вызовом sleep на
прерванном потоке) созданный поток завершает выполнение. Управление
выполнением кода извне осуществляется с помощью связки функций interrupt
и interrupted. Interrupt позволяет установить внутренний флаг, который
затем проверяется в переданном на выполнение коде с помощью
вспомогательной функции (обычно бросающей исключение при соответствующем
значении флага).

Так как из рабочих потоков нельзя напрямую взаимодействовать с UI,
обновление интерфейса происходит посредством метода View.post,
передающего в очередь сообщений главного (UI) потока задачу обновить
привязанное поле (см. функцию updateTimer).

### Решение 2 (AsyncTask)

Разработанный класс MainActivity:

![](media/image3.png){width="6.417562335958006in"
height="7.938607830271216in"}

Рисунок 3 MainActivity.kt

В данной реализации для организации многопоточности использован класс
AsyncTask (deprecated), предоставляющий более удобный интерфейс
взаимодействия с потоками. При наследовании абстрактного класса
переопределен метод doInBackground.

При создании экземпляра класса и вызова метода execute() экземпляр во
вспомогательном потоке проходит через собственный жизненный цикл. Влиять
на выполнение AsyncTask из других потоков позволяет связка функции
cancel и свойства isCancelled.

![](media/image4.png){width="6.250872703412074in"
height="2.958746719160105in"}

Рисунок 4 Вложенный класс MyTask

### Решение 3 (Kotlin Coroutines)

Корутины являются "обёрткой" над потоками и более просты в
использовании. В onResume запускается корутина, отвечающая за счёт. Она
представляет из себя бесконечный цикл, остановить который можно только
вместе с отменой самой корутины. Это производится с помощью job.cancel в
onPause.

![](media/image5.png){width="5.302823709536308in"
height="8.34491469816273in"}

Рисунок 5 Класс MainActivity.kt

Задача 2. Загрузка картинки в фоновом потоке (AsyncTask)
--------------------------------------------------------

### Задание

Создать приложение, которое скачивает картинку из интернета и размещает
ее в ImaveView в Activity на основе предоставленного кода.

### Решение

Разработанный код MainActivity:

![](media/image6.png){width="6.496527777777778in"
height="3.2979166666666666in"}

Рисунок 6 MainActivity.kt

По нажатию на кнопку создается экземпляр класса DownloadImage, далее на
нем вызывается execute, после чего задача решается во вспомогательном
потоке.

При наследовании абстрактного класса для DownloadImage переопределен ряд
методов, а именно:

-   onPreExecute;

-   doInbackground;

-   onPostExecute.

Помимо переопределения методов AsyncTask добавлена функция загрузки
изображения по заданному
URL-адресу:![](media/image7.png){width="6.496527777777778in"
height="8.554166666666667in"}

Рисунок 7 Класс DownloadImage

Задача 3. Загрузка картинки в фоновом потоке (Kotlin Coroutines)
----------------------------------------------------------------

### Задание

Переписать предыдущее приложение с помощью Kotlin Coroutines.

### Решение

Для решения задачи разработан следующий код MainActivity:

![](media/image8.png){width="6.496527777777778in"
height="5.870138888888889in"}

Рисунок 8 MainActivity.kt

В приведенной реализации использованы вложенные корутины. Dispatchers.IO
указывает корутине взять один из I/O потоков и выполняться в нём.
Предполагается, что в нем станут производиться длительные операции, а
также действия, связанные с I/O и работой с сетью.

Задача 4. Использование сторонних библиотек
-------------------------------------------

### Задание

Применить одну из предложенных стандартных библиотек для решения задачи
скачивания изображения в фоне.

Выбранная библиотека: Picasso.

### Решение

Добавим необходимые зависимости в Gradle(app)-файл:

***dependencies {***

> ***implementation 'com.squareup.picasso:picasso:2.71828'\
> …***

***}***

Воспользуемся предложенным на StackOverflow кодом для загрузки
изображения:

***Picasso.get().load("http://img\_url").into(imageView)***

Добавим код в обработчик нажатия на кнопку:

![](media/image9.png){width="6.136272965879265in"
height="3.8234503499562553in"}

Рисунок 9 Загрузка картинки с помощью библиотеки Picasso

Выводы
======

В ходе выполнения лабораторной работы приобретены навыки разработки
многопоточных приложений, усвоены различия между UI-потоками, потоками
ввода-вывода и рабочими потоками, рассмотрены способы взаимодействия с
UI из рабочих потоков. Также освоены три основных API для разработки
многопоточных приложений:

-   Java Threads – программное представление потока процесса, который
    запускается с помощью создания экземпляра класса Thread и вызова
    функции start, выполнение которого может управляться извне при
    помощи вызова функции interrupt и контроля флага interrupted в
    исполняемом коде;

-   AsyncTask – обладающее жизненным циклом представление задачи,
    выполняемой в рабочем потоке, callback-методы которой выполняются
    как в рабочих потоках для выполнения самой задачи, так и в UI-потоке
    для отображения результатов и изменений;

-   Kotlin Coroutines – программное представление прерываемой
    сопрограммы, которая может быть либо приостановлена для переключения
    на выполнение другого кода, либо запущена параллельно вызываемой
    подпрограмме в отдельных потоках.
